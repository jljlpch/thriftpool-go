package main

import (
	"bytes"
	"fmt"
	"go/format"
	"text/template"
)

const proxyTemplate = `// {{.ProxyPackage}} Autogenerated by thriftgen generator
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
package {{.ProxyPackage}}

import (
  "github.com/lysu/thriftpool-go/pool"
  "{{.InterfaceImport}}"
)

type ClientFactory func() (*{{.ClientType}}, error)

type thriftResource struct {
  addr string
  client *{{.ClientType}}
  pool pool.Pool
  circuitBreaker *circuit.CircuitBreaker
}

func (r *thriftResource) Close() error {
  return r.pool.Return(nil, r, false)
}

func (r *thriftResource) RawClose() error {
	return r.client.Transport.Close()
}

func (r *thriftResource) Address() string {
  return r.addr
}

func (r *thriftResource) SetCircuitBreaker(circuitBreaker *circuit.CircuitBreaker) {
	r.circuitBreaker = circuitBreaker
}

func (r *thriftResource) CircuitBreaker() (*circuit.CircuitBreaker, error) {
	if r.circuitBreaker == nil {
		return nil, fmt.Errorf("CircuitBreaker init failure")
	}
	return r.circuitBreaker, nil
}

type Proxy struct {
	clientFactory ClientFactory
	pool          pool.Pool
}

type Opt struct {
	InitNum               int
	MaxCap                int
	MaxIdleTimeout        time.Duration
	ConTimeout            time.Duration
	SoTimeout             time.Duration
	BreakerTimeToOpenUnit time.Duration
	BreakerTimeToOpenMax  time.Duration
}

func New(address []string, clientFactory ClientFactory, opt Opt) *Proxy {
	p := &Proxy{
		clientFactory: clientFactory,
	}
	p.pool = pool.NewGroup(address, func(addr string, pool pool.Pool) (pool.Resource, error) {
    client, err := p.clientFactory()
    if err != nil {
      return nil, err
    }
		return &thriftResource{
      addr: addr,
      pool: pool,
      client: client,
    }, nil
	}, pool.Opt{
		InitNum:        opt.InitNum,
		MaxCap:         opt.MaxCap,
		MaxIdleTimeout: opt.MaxIdleTimeout,
		TimeToOpenUnit: opt.BreakerTimeToOpenUnit,
		TimeToOpenMax:  opt.BreakerTimeToOpenMax,
	})
	return p
}

{{range .Functions}}
func (p *Proxy) {{.Name}}({{range .Params}}{{.Name}} {{.Type}}, {{end}})({{range .Res}}{{.Name}} {{.Type}}, {{end}}){
	poolResource, err := p.pool.Get(nil)
	if err != nil {
		return
	}
	defer p.pool.Return(nil, poolResource, false)
	return poolResource.(*thriftResource).client.{{.Name}}({{range .Params}}{{.Name}}, {{end}})
}
{{end}}
`

type Generator struct {
	InterfaceImport  string
	InterfacePackage string
	InterfaceName    string
	ProxyPackage     string
	Functions        []Func
}

type ThriftInterface struct {
	InterfaceImport string
	ProxyPackage    string
	ClientType      string
	Functions       []Func
}

func NewGenerator(iface string) (g *Generator, err error) {
	ifaceImport, ifacePkg, ifaceName, err := FindInterface(iface)

	if err != nil {
		return nil, err
	}

	proxyPackage := ifacePkg + "proxy"

	functions, err := Functions(iface)

	if err != nil {
		return nil, err
	}

	var pingFunc *Func

	for _, f := range functions {
		if f.Name == "Ping" && len(f.Params) == 0 && len(f.Res) == 1 && f.Res[0].Type == "error" {
			pingFunc = &f
		}
	}

	if pingFunc == nil {
		return nil, fmt.Errorf("Interface %s does not contain function Ping() error", iface)
	}

	g = &Generator{
		InterfaceImport:  ifaceImport,
		InterfacePackage: ifacePkg,
		InterfaceName:    ifaceName,
		ProxyPackage:     proxyPackage,
		Functions:        functions,
	}

	return g, nil
}

func (g *Generator) render() (source []byte, err error) {
	ti := &ThriftInterface{
		InterfaceImport: g.InterfaceImport,
		ProxyPackage:    g.ProxyPackage,
		ClientType:      g.InterfacePackage + "." + g.InterfaceName + "Client",
		Functions:       g.Functions,
	}

	tmpl, err := template.New("tpl").Parse(proxyTemplate)

	if err != nil {
		return nil, err
	}

	buf := &bytes.Buffer{}

	err = tmpl.Execute(buf, ti)

	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (g *Generator) format(source []byte) (code []byte, err error) {
	return format.Source(source)
}

func (g *Generator) Generate() (code []byte, err error) {
	source, err := g.render()

	if err != nil {
		return nil, err
	}

	code, err = g.format(source)

	if err != nil {
		return nil, err
	}

	return code, nil
}
